##################################################################################################################
#
#      ppi-server config file of measure routines
#      writen by Alexander Kolli <ppi@magnificat.at>
#
#
#  this configuration file measure.conf have one or more folder which running
#  in extra threads. All folder have one or more subroutines called with attribute name
#  example:
#        folder= <folder name>
#        name= <subroutine name>
#        type= <type> (described later)
#        [some parameters for subroutine]
#        
#        name= <new subroutine for same folder>
#        ...
#
#        folder= <new folder name>
#        name= <subroutine name> (for new folder)
#        ...
#
#  An folder with one or more subroutines describe an working list (folder list)
#  and running parallel inside different threads.
#  Some times be necessary that more folder lists which has the same behavior but often
#  other subroutines (to grab into other folder lists) should be exist.
#  In this case, it's possible to define the folder in an object
#  where has the object and the folder the same name
#  and inside the folder will be also described the result folders with different subroutines
#  example:
#        object= <object name>
#        folder= <folder1>
#        subvar= <different subroutine inside folders>
#        folder= <folder2>
#        subvar= ....
#        ...
#        folder= <object name>
#        name= <subroutine name>
#        [content of different subroutines]
#        object= NULL <- end of object
#                        will be only needed when
#                        an normally folder (without object) will be the next
#                        the best idea, to don't forget when later an normally folder follow,
#                        is to close all object's with NULL
#  When inside the object an folder grab to an other object
#  and inside the grabbing subroutine is defined the object-name as folder,
#  the subroutine in first folder of object grab to the first folder of other object,
#  the second to the second and so on
#
#  An subroutine hold always an current value with last changing time.
#  when in any parameter defined an variable with [folder:]<subroutine>
#  there is always meant the value and by calculation of this variables
#  as example from 'begin', 'while' or 'end' the subroutine take from the variable
#  with the newest last changing time the last changing time as own
#  Subroutines has also sub-variables to refer to an specific information
#  (but they do not refer to the last changing time)
#  as example: [folder:]<subroutine>[.<sub-variable>]
#  follow sub-variables are allowed
#  for all subroutines:
#    changed   -    whether the variable was changed by last passing
#                   when an subroutine ask for changing own subroutine,
#                   the subroutine know only when subroutine was changed
#                   from outside
#    value     -    same as value of subroutine
#                   but has no last changing time
#    lastvalue -    old value of subroutine before changing
#    time      -    current last changing time of subroutine
#  for subroutines with type TIMER: (see also type TIMER bellow)
#    run       -    whether TIMER routine measure to setting time
#    startval  -    time measure was starting by this value
#                   or current value when not running
#  for an hole folder list
#    run       -    to check whether an folder list is running
#                   or be defined from any other folder
#                   ( with subroutine from type SET
#                     or when any required variable changed )
#                   to starting
#                   ( when this case (<folder>.run) be defined in an subroutine
#                     and the folder starting or stopping, the subroutine
#                     will not be informed. Only by passing subroutine they know )
#                   ( when this case (<folder>.run) be defined in an subroutine
#                     and the own folder list has also an subroutine with the same name
#                     and that type is from TIMER
#                     the calculation take always the <folder>.run, not the <subroutine>.run.
#                     For this case when you want <subroutine>.run
#                     write also in the own folder <own folder>:<subroutine>.run
#                     which otherwise you do not need                                          )
#
#  On any place (better before any defined folder/object, or at end of any) 
#  can also be defined an external file (with parameter file and value as filename with path)
#  where be the same structure object/folder/subroutines (see for example the definition bellow).
#
#  Follow standard types can be set.
#  They need the properties which are in <> brackets or optional in [] brackets.
#  For the property attribute action, all values are optional
#  read the description under PROPERTIES and ACTIONS
#
#
#   TYPES:         properties and actions:
#  --------       -------------------------
#
#   DEBUG          properties: [begin&|while&|end], [log], [string], [value], [perm]
#                  actions: print
#             [ this subroutine is only for debugging in the same command line shell where the ppi-server is running,
#               or logging into log-file when property log be set
#               the string from parameter [string] and value from parameter [value] will be written to command line (log-file)
#               when the case of begin, while, end is given or the subroutine was set from outside
#               maybe with ppi-client to DEBUG (./ppi-client DEBUG <folder>:<subroutine>)
#               The own value of the DEBUG subroutine is true by writing output elsewhere false
#               so you can define more DEBUG subroutines which link to one DEBUG subroutine with property while
#               and you have than set only one DEBUG subroutine to write output.
#               More string parameters and value parameters can be set to define the debug string
#               The output is writing on interaction from [string] and [value]. Begins always with string if set.
#               If the [value] should be the first, define first an null string (string= "")
#               By debugging only this subroutine the debug level do not show starting and ending folder in debug mode      ]
#
#   READ           properties: [begin&|while&|end], <src>, [time]
#                  actions: db, hold, debug
#             [ read address from internet
#               currently only http:// requests allowed
#               while passing the subroutine inside worker list without reaching any truly begin/while parameter
#               the value of subroutine is always 0
#               otherwise the subroutine hold the request code from server
#                       102 - Processing (while sending request)
#                       200 - OK or
#                       400 - Bad Request
#                       all other codes see http://en.wikipedia.org/wiki/List_of_HTTP_status_codes
#               also when starting from an other subroutine with type TIMER
#               the subroutine hold the request code start the own working list (folder)
#               and by first passing the request code stay in subroutine until for the next passing       ]
#
#   SET            properties: <begin&|while&|end>, <from>, <set>, [perm], [default]
#                  actions: db, noinfo, fromtime
#             [ with this subroutine your can set an value from one ore more parameter 'from' to
#               one ore more parameter 'set' in the case of begin, while and end.
#               If you have more 'set' parameter you can have one 'from' parameter, in this case you set all subroutines
#               with the same 'from' parameter value, or the same count of 'from' parameter than 'set' have to be exist.
#               The own value of the SET subroutine will be true when the case of begin, while, end is given
#               elsewhere false
#               the last changing time of subroutine which will be set is always from the 'from' parameter,
#               only when there no time be set, the changing time will be taken from the begin, while, end cases            ]
#
#   SHELL          properties: <begin&|while&|end>, <begincommand&|whilecommand&|endcommand>, [runuser]
#                  actions: db, last, wait, block, noinfo, noerrorlog, debug
#             [ starts an shell command in the case of <begin|while|end> is correct.
#               The value of the subroutine is the exit code of the starting shell script when action wait or block be defined,
#               by an ERROR value is -1 or 127. See log File for Errors, or debug subroutine.
#               If action wait or block not be set value can be 0 when no command produced,
#               1 for begin-, 2 for while- and 3 for endcommand.
#               The script output only be seen when you debug the subroutine with ppi-client DEBUG <folder>:<subroutine>
#               The started script can also write some commands per normally printing over stdout to the ppi-server:
#                       PPI-SET [-t <unixtime[.milliseconds[microseconds]]>] <folder>:<subroutine> <value>
#                                                -     to write directly into ppi-server subroutines
#                                                      you can use the way with an separate connection over ppi-client
#                                                      but also this one for an better performance.
#                                                      When used optional option -t, you can also set the actually 
#                                                      time of modification into the subroutine which will be needed
#                                                      from any TIMER subroutine to measure to exact time
#                                                      (can be defined in an bash script with `date +"%s.%N"`)
#                       PPI-DEF stop <signal>    -     normally by stopping ppi-server, shell starting routine
#                                                      sending to started shell script and all child processes
#                                                      the signal SIGTERM for termination.
#                                                      with command "PPI-DEF stop" the server change sending signal
#                                                      follow signals are allowed:
#                                                                             SIGHUP
#                                                                             SIGINT
#                                                                             SIGQUIT
#                                                                             SIGTRAP
#                                                                             SIGABRT
#                                                                             SIGBUS
#                                                                             SIGKILL
#                                                                             SIGUSR1
#                                                                             SIGUSR2
#                                                                             SIGPIPE
#                                                                             SIGALRM
#                                                                             SIGTERM
#                                                                             SIGSTOP
#                       PPI-DEF cycle-begin      -     when action 'block' be set (see under action: block)
#                                                      to hold the output for debugging closer
#                                                      output beginning always new when this command passed
#                                                      otherwise the hole output can be grow to 1000 lines 
#                       PPI-DEF log <error-level> <string:|begin|end>
#                                                -     writing log message into log files
#                                                      error-level be are the same then in server.conf
#                                                               DEBUG
#                                                               INFO
#                                                               WARNING
#                                                               ERROR and
#                                                               ALERT    
#                                                      when after the error-level be defined the name 'string:'
#                                                      the one character string line after the colon will be written
#                                                      into the log file
#                                                      when defined the word 'begin' after the log level
#                                                      the hole next output will be written
#                                                      until the shell command writing an new PPI-DEF log command with end
#                                                      but no error-level   
#                       PPI-DEF noerrorlog         -   do not write shell script error into log file
#               When running folder inside an object, for parameters of begincommand/whilecommand/endcommand
#               can be also defined an script with parameter subvar inside folder.
#               This variable can then reached inside shell command with ${<subvar>}                                        ]
#
#   SWITCH         properties: <begin&|while&|end>, [finished], [lwhile], [link], [perm], [default], [perm]
#                  actions:    db, noinfo, exact
#             [ the type SWITCH is an holder for 0 or 1
#               beginning or ending in the case of defined subroutines
#               and can also set from outside, when permission given     ]
#
#   TIMER          properties: [mtime|(year&|month&|day&|hour&|min&|sec&|millisec&|microsec)], 
#                              [direction], <begin&|while&|end>, [start], [setnull],  [lwhile], [link], [perm]
#                  actions: db, alwaysbegin, poll, exact, wait, activate, unixtime, weekday, DST 
#                           years, months, days, hours, minutes, seconds, sec, micro, noinfo
#             [ this type have five functionalities:
#               1 - polling the time inside settings action of 'year', 'month', 'day', 'hour', 'min' or 'sec'
#                   in the case of begin/while/end when set, otherwise all the time
#               2 - count the time in the case of begin and or while down to 0
#                   to an setting date when in subroutine action 'activate' be set
#                   the date can be defined with attribute parameters of subroutine year, month, day, hour, min and sec
#               3 - count the time in the case of begin and or while down to 0
#                   beginning by the time set with day, hour, min, sec, millisec, microsec or allone with mtime from other subroutine
#                   previously when a situation arises that while ending or property end is achieved, only when set,
#                   the count down to 0 is also reached.
#                   The next pass of this subroutine when 0 was reached before, the value is -1
#                   value -1 is also the case if no count down running.
#                   When the count down finished with 0, but inside while/end the routine found no ending
#                   and action 'poll' be set, the subroutine begins again to run with full time.
#               4 - count also the time like point 3, but when stopping the subroutine hold the actual value
#                   and this case can count also in both direction is given when the property direction be set with 0 or 1
#               5 - measure the time between the subroutine active inside begin/while/end
#                   if no property of mtime or day, hour, min and so on be set.
#               variants 1, 2 and 4 measure or count down in seconds by default (same as action sec be set)
#               when action micro be set, subroutine measure or count down in microseconds
#               variant 3 make the count down only for seconds.   
#               All variants measure the time, for begin to end, when the subroutine running
#               only for variants of 3 or 4, begin/end time will taken from other subroutines changing,
#               defined inside the parameters begin/while/end                                                                       ]
#
#   VALUE          properties: [min & max], [default], [while], [value], [lwhile], [link], [perm]
#                  actions:    int, db, noinfo
#             [ VALUE is an holder in the range of min and max
#               can set from outside when permission given,
#               or defined with parameter 'value' (can exist more than ones)
#               which value parameter will be used when more set than one
#               can be defined in the 'while' parameter (beginning with 0).
#               Similarly, the value of this
#               subroutine will be shared with other when the link parameter be set.
#               The definition to use which link is also defined in 'lwhile'
#               If min and max not be set or with false values defined,
#               the range can have all values                                         ]
#
#
#   PROPERTIES:
#  -------------
#          the value of some properties can be a truth-value 'true' or 'false', comparison of numbers
#          or point to an other subroutine intern of folder <subroutine-name>
#          or show to an subroutine outside the folder <folder-name>:<subroutine-name>.
#          if this value is not null ('0') the case is given, same like 'true'. Elsewhere by null the case not given 'false'.
#          The subroutines can also comparing (=><) with an value or an other subroutine
#          and more comparisons can be separated with an & (and) or an | (or).
#          inside this property can also defined an if-sentence with <value> ? <then> : <else>
#          But heads up! when you have an colon ':' inside the then clause, define it under brackets '(<then>)'.
#          This hole stuff, for better overview in the properties description we call it as defined-value
#          elsewhere it be called as subroutine or number
#
#   begin          - for types SWITCH, SET and TIMER
#                     do reading or writing if begin status occurring
#                     specific for type TIMER by no set action measure:
#                         subroutine beginning always with full time again
#                     the value can be an defined-value
#
#   begincommand   - for type SHELL
#                     the value can be an shell command for the commandline
#                     this command will have effect when the case of <while> begin
#                     the value can be an string of shell commands
#                     and can contain predefined subvar's like ${<subvar>}
#
#   day            - for type TIMER
#                     after days the end will be reached
#                     the value can be an integer of hours
#
#   debug          - for type SHELL
#                     normally shell script is only logging output in an queue
#                     when soubroutine set for an debug session
#                     when now shell script hanging because an error or somthing else
#                     while server running and you have not all the time set the debug session
#                     you start debug session but output wasn't logging to see error
#                     set this action and you can see output to error also 
#                     when you set debug session later.
#                     This behavior is only neccesary when SHELL soubroutine
#                     was defined with action block
#
#   default        - for types SWITCH, SET and VALUE
#                     when the server starting the first time
#                     or by every start if the action db not set
#                     elsewhere the default not be set and no db
#                     the value to begin is 0#                    
#                     the value can be 0 or 1 for SWITCH
#                     or the defined range for VALUE
#
#   direction      - for the type TIMER
#                     advice the subroutine in which direction to count
#                     0 or lower - the subroutine count in direction to 0
#                     1 or higher - in direction to full setting time
#                     the value can be an defined-value
#
#   DST            - for type TIMER
#                    daylight saving time
#                    subroutine present always whether be the summer time (1 = true)
#                    or winter time (0 = false)
#
#   end            - for the type SWITCH, SET and TIMER
#                     end read or write ending when state occurring
#                     specific for type TIMER by no set action measure:
#                         when state occuring before count down was finished
#                         the value of subroutine will be set directly to 0                    
#                     the value can be an defined-value
#
#   endcommand     - for type SHELL
#                     the value can be an shell command for the commandline
#                     this command will have effect when the case of <while> ending
#                     and can contain predefined subvar's like ${<subvar>}
#
#   file           - on any place (better before beginning an folder or on end of file)
#                    can also be defined any external files
#                    which have the same structure of folder and subroutines like this file
#                    the value can be an string of path definition with including file
#
#   finished       - for type TIMER when case is 3 (count time down to 0) and action exact be set
#                     include time from ending to be finished inside running length of timer 
#                     the value can be an defined-value 
#
#   foldervar      - parameter for folder (no subroutines)
#                    can be used inside an object to describe folder-names
#                    which should be used from the different folder lists
#                    the value can be an sting to define the variable which used inside object-folder list
#                    followed from an is same sign ('=') and the different folder name
#                    used in the differnet folders of object
#
#   from           - for type SET
#                     calculate the value from this string
#                     the value can be an defined-value
#
#   hour           - for type TIMER
#                     after houers the end will be reached
#                     the value can be an integer of hours
#
#   inform         - parameter for folder (no subroutines)
#                    when this parameter be set, the folder will be informed
#                    only when the result be true
#                    when the parameter defined with false,
#                    the folder will be running in no time
#                    this can be used when the folder only be used for
#                    global variables. Which will be set and read from
#                    outside or other folders
#                    the value can be an defined-value
#
#   link           - for type SWITCH, VALUE and TIMER
#                     Share the own value with an other subroutine.
#                     When be used more than one 'link' parameter,
#                     which used can be defined with the parameter 'lwhile'.
#                     By more links, 'lwhile' should have the number of currently
#                     shared link, beginning with 1 (see property lwhile)
#                     the value can be one [folder:]subroutine
#
#   log            - for type DEBUG
#                     logging string/value into log-file
#                     when no log property be set or also action 'print' be set
#                     the string/values are be displayed on command line
#                     value can be an string of
#                                  DEBUG
#                                  INFO
#                                  WARNING
#                                  ERROR
#                                  ALERT    
#
#   lwhile         - for type SWITCH, VALUE and TIMER
#                     calculate which link parameter should be used
#                     if no lwhile parameter be set, but an link parameters
#                     subroutine will be an fix share to the linked [folder:]subroutine
#                     When result of lwhile is 0, no link be set
#                     1 for the first link, 2 for the second and so on
#                     by result of higher than link's exist, server writes an WANING into log-file#                    
#                     the value can be an defined-value
#
#   max            - for type VALUE
#                     maximal range for value
#                     if min or max not be set, the value have the hole range
#                     the value can be an floating value when action int not be set,
#                     elsewhere an integer
#
#   microsec       - for type TIMER when action micro be set
#                     after microseconds the end will be reached
#                     (1,000,000 microseconds are 1,000 milliseconds are 1 second)
#                     the value can be an integer of microseconds
#
#   millisec       - for type TIMER when action micro be set
#                     after milliseconds the end will be reached 
#                     (1000 milliseconds are 1 second)
#                     the value can be an integer of milliseconds
#
#   min            - for type VALUE
#                     minimal range for value
#                     if min or max not be set, the value have the hole range
#                     the value can be an floating value when action int not be set,
#                     elsewhere an integer
#
#   min            - for type TIMER
#                     after minutes the end will be reached
#                     the value can be an integer of minutes
#
#   month          - for type TIMER when action micro not be set
#                     after how many months the end should be reached
#                     the value can be an integer of months
#
#   mtime          - for type TIMER
#                     this time define running length of subroutine
#                     if this property set, the other times with day&|hour&|min&|sec&|millisec&|microsec
#                     can not be set.
#                     the value can be an defined-value maybe to an other TIMER with action time
#
#   perm           - for all types
#                     the given permission by access from outside to the server
#                     if no permission be set, nobody has access to the subroutine
#                     root has access to all read and write groups which be set
#                     the value can be a group defined in access.conf
#
#   policy         - parameter for folder (no subroutines)
#                     by measure exact time with any TIMER subroutine
#                     the greatest problem will be when to much folder threads
#                     running to often. This can be checked with the ppi-client command SHOW
#                     which folder running in an defined time. (see ppi-client --help)
#                     this parameter can be used to change the kernel policy for running folder threads
#                     WARNING: before set an folder to an real-time policy, check before with SHOW
#                              that the folder realy stopping after measure
#                              otherwise the ppi-server can freeze your hole system
#                     follow policy are allowed:
#                         SCHED_OTHER   - the standard round-robin time-sharing policy
#                                         can only be used at static priority 0
#                                         will be used when no other policy be set
#                         SCHED_BATCH   - This policy is similar to SCHED_OTHER
#                                         with the only differ that the wakeup behavior
#                                         has an small scheduling penalty
#                                         can only be used at static priority 0
#                                         (since Linux Kernel 2.6.16)
#                         SCHED_IDLE    - folder will be running inside extremely low priority
#                                         (lower even than a +19 nice value)
#                                         can only be used at static priority 0
#                      "real-time" policies
#                         SCHED_FIFO    - a first-in, first-out policy
#                                         block all other user space threads on system
#                                         which running with other policy or lower priority
#                                         can be used with static priorities higher than 0
#                                         an SCHED_FIFO folder with the highes priority will be running
#                                         from beginning to end when an TIMER subroutine do not sleep any time
#                                         after end or by sleeping, the folder thread will be put at the end 
#                                         of the list for its priority
#                         SCHED_RR      - a round-robin policy with timeslices
#                                         has the same behavior than SCHED_FIFO, except that
#                                         each process is only allowed to run for a maximum time quantum
#                                         (the time quantum seen inside log-file by starting folder)
#
#   priority       - parameter for folder (no subroutines)
#                    set the priority for setting policy
#                    the value can be an integer of follow numbers
#                    policy SCHED_OTHER, SCHED_BATCH or SCHED_IDLE can only has priority 0
#                    SCHED_FIFO or SCHED_RR priority from 1 (lower) to 99 (higher)
#              
#   run            - parameter for folder (no subroutines)
#                    can be used when inside folder is defined an TIMER subroutine
#                    for exact stopping and with an finished parameter
#                    this means when more folders defined with the same definition word
#                    after this parameter (exp. run= dowork) the server split the estimation
#                    entry which be written into database. (more definition words can be set)
#                    as example: when you have 3 folder it hold not only value reachend
#                                for every folder, assort reachend100 for the first
#                                reachend010 for the second and reachend001 for third
#                                and also reachend110 for folder one when the first and the second running
#                                as well reachend110 for the second and so on
#                                reachend011 when second and third running and reachend111 for every folder
#                                when all tree running
#                    folder running means that the exact TIMER subroutine count down the setting time
#                    an better result for running you can get when you define after the definition word
#                    seperated with an colon, an own defined-value (exp. run= dowork: running_folder = 1)
#                    than the folder means to run only when this case is true
#                    this will be an better idea, because one folder starting as first with maybe estimation
#                    for reachend100, the second with reachend111 by same time running
#                    and the third, because the first starting ending also as first, has reachend011
#                    in this case with the own defined-value you can better handle which folder running
#                    because when the TIMER routine which estimated with reachend100 pass as second time
#                    the exact TIMER subroutine, it will be calculate the new estimation with also reachend111
#                    than after that, you know that no folder running, you can set subroutine running_folder
#                    from example again to 0, so you know that all three folders has the estimation with reachend111
#
#   runuser        - for type SHELL
#                     the value can be an string of existing user on system
#                     this command allow the subroutine to start the shell command
#                     inside specific user account
#                     the value can be an string of shell commands
#
#   sec            - for type TIMER
#                     after seconds the end will be reached
#                     the value can be an integer of seconds
#
#   set            - for type SET
#                     set an value to this subroutine
#                     the value can be an subroutine or folder:subroutine
#
#   setnull        - for type TIMER
#                     subroutine will be set to null
#                     the value can be an defined-value
#
#   src            - for type READ
#                     describe an address from internet for http protocol
#                     beginning with 'http://'
#                     the value can only be an string of address
#                     and can contain predefined subvar's like ${<subvar>}
#
#   start          - for type TIMER
#                     subroutine starting external ports (this time only SHELL and READ subroutines)
#                     for bidirectional running per calculated time
#                     this parameter is only usable when action exact be set
#                     value can be an string of [folder:]<subroutine>
#
#   string         - for type DEBUG
#                     can be an string for output on command line
#                     the value can be an string
#                     and can contain predefined subvar's like ${<subvar>}
#
#   subvar         - parameter for folder (no subroutines)
#                    can be used inside an object to describe subroutine-names
#                    which should be used from the different folder lists
#                    the value can be an sting to define the variable which used inside object-folder list
#                    followed from an is same sign ('=') and the different subroutine name
#                    used in the differnet folders of object
#
#   time           - for type READ
#                     can be follow strings to set time for subroutine when reading
#                         start   - time before starting to read
#                         connect - time after connection to other server
#                                   before sending command which file should reading
#                         send    - time after sending which file to read
#                                   and when get back the first block of answer
#                                   this is mostly the same time as end
#                                   because the hole file sending back, is littler then
#                                   the bit blocks sending from server
#                         end     - time after getting the hole file
#                                   default value when no time property be set
#
#   value          - for type VALUE and DEBUG
#                     define the content of an VALUE subroutine.
#                     specific for type VALUE
#                        when be used more than one value, which used can be defined
#                        with the parameter while.
#                        When the result from while is 0, the value for writing to output
#                        is the defined first value. By 1 the second and so on.
#                        If the result is not defined in count of values (out of range) the default value will be
#                        the first if to low or the last when to high
#                     the value can be an defined-value
#
#   weekday        - for type TIMER
#                    subroutine present the current day of week
#                    0 for Sunday, 1 for Monday ... to 6 for Saturday
#
#   while          - for types SWITCH, SET, VALUE, TIMER and SHELL
#                     do reading or writing while state be set
#                     parameter beginning only when parameter begin not set
#                     but can ending before parameter end will be reached for ending
#                     specific for type VALUE:
#                        can also define which value parameter be used
#                        otherwise when no value parameter defined
#                        this result will be the value
#                     specific for type TIMER by no set action measure:
#                        when no begin parameter be set by running count down
#                        count down do not begin again with full time
#                        also by ending before count down finished
#                        count down running down to 0 and then -1
#                     the value can be an defined-value
#
#   whilecommand   - for type SHELL
#                     the value can be an shell command for the command line
#                     this command have effect during the case of <while> be given
#                     the value can be an string of shell commands
#                     and can contain predefined subvar's like ${<subvar>}
#
#   year           - for type TIMER when action micro not be set
#                     after how many years the end should be reached
#                     the value can be an integer of years
#
#
#   ACTIONS:
#  ----------
#    one or more actions can be set by the property action
#    when more be set, it must be separated with an pipe ('|')
#
#   activate    - for type TIMER
#                  count down the second to an setting date
#
#   alwaysbegin - for type TIMER
#                  begin count down of full time by every begin
#                  this action is only allowed when TIMER type run in case 2
#
#   block       - for type SHELL
#                  if subroutine is defined with the action wait and the shell command do not
#                  ending directly, it will be block the hole subroutine and maybe also other folders
#                  in this case define the subroutine with action block. And while during the shell
#                  command runs, the subroutine starting no new command, otherwise he lock only for result
#                  This action is only useful when also action wait is set, and gives an warning by start server
#                  when this action be set, only the parameter whilecommand is allowed
#
#   debug       - for type READ
#                  only when subroutine defined for debug session
#                  display the hole content of file get back to reading
#                  otherwise when action not be set
#                  it will only display the first 10 rows
#
#   db          - for all types
#                  writing actual state on database
#                  witch values are will be write from subroutines with this action
#                  and how long the values are holding in database
#                  you can read in default.conf or some defined configuration files
#                  for explicitly modules
#
#   exact       - for type TIMER in case of 3 or 4
#                  exclude the time of start folder to start subroutine
#                  (as hole folder running time) from running length of folder
#                  and wait then inside subroutine to the exact time
#
#   fromtime    - for type SET
#                  writing changing time from every 'from' property
#                  into foreign subroutine
#                  elsewhere will be writing time from begin/while/end properties
#                  which is also the subroutine changing time
#
#   hold        - tor type READ
#                  try to hold connection to server
#
#   int         - for type VALUE
#                  when the value or subroutine can have only an integer
#                  elsewhere an floating number
#
#   last        - tor type SHELL (when no wait action be active)
#                  showing for result last triggered command
#                  this means the subroutine value is only the first time after starting 0
#                  and after doing the first begin-, while- or endcommand always the number 
#                  which shell-script was done as last begincommand ('1'),
#                  whilecommand ('2') or endcommand ('3')
#
#
#   measure     - for type TIMER
#                  calculate time length and not as default an count down
#
#   micro       - for type TIMER
#                  result is before decimal point full seconds and then milliseconds
#                  and microseconds in 1000'th steps
#                  the highest value can only be 60 * 60 seconds (3600)
#
#   noerrorlog  - for type SHELL
#                  do not write shell script error into log file
#                  maybe you need the result of script inside the subroutine and need for this reason no error in log file.
#                  If it's possible to write the command (PPI-DEF noerrorlog) into the script
#                  it's an better job to do this shortly before exit with number.
#                  Because when script ending on other position with an real error
#                  you can not see the error in log file (Only by debugging folder:subroutine)
#
#   noinfo      - for all types
#                  when any values from subroutine defined in begin/while/end was changed
#                  running inside an other folder, or before own subroutine in same folder
#                  folder from this subroutine will be started when this action not be set
#                  this action can be neccesary when begin/while/end only should be checked
#                  when an subroutine before was changed. In this case the hole folder
#                  do not running all the time when not needed and so performance can be holded lower
#                 for type SHELL
#                  aditional to the behavior before
#                  the external started thread write no sucessful code into subroutine
#                  where the subroutine also now the time when the shell command starting
#                  in this case, the subroutine write self the code 1, 2, or 3
#
#   poll        - for type TIMER in case 2 or 4
#                  beginning time measure again by 0 or full time
#                  when no ending found inside while or end parameters
#                  this action is only allowed when TIMER type run in case 2 or 4
#
#   print       - for type DEBUG
#                  display string/value on command line
#                  this action is default when no log parameter be set
#                  when log parameter set, the subroutine logging into log file
#                  and do not display on command line
#                  elsewhere when log parameter and this property be set 
#                  the subroutine write for both
#
#   sec         - for type TIMER (default)
#                  result is an integer of seconds
#
#   unixtime    - for type TIMER in case 1
#                  can be set in combination with years, months, days, hours, minutes or seconds
#                  and write by every polling the seconds since 1970.01.01 00:00:00 into subroutine
#                  when property set allone without polling commands (year, months, ...)
#                  secons since 1970 will be write by every passing when begin/while/end is true
#
#   wait        - for type SHELL
#                  subroutine should waiting for end of command
#                  in this case the value of the subroutine is the return value of the command
#                  when this property be set, the shell routine blocking the hole folder
#                  in which subroutine running for hole time while shell script running
#                  when shell script running as other user than working list,
#                  subroutine blocking also all other folders which need access to an shell script
#                  with the same other user
#                 for type TIMER
#                  only allowed when also defined action 'exact' and no parameter 'start'
#                  do not start folder again for exact stopping,
#                  wait inside subroutine until end time is reached
#
##################################################################################################################



#
# this is an default example to show all exist components
# in examples/components.conf there only an subroutine
# from type SWITCH and type VALUE. Usable components
# are inside of client/components.desktop.
# For useable subroutines take a look inside
# examples/subroutines.conf
#-------------------------------------------------------------------
file= examples/components.conf
file= examples/subroutines.conf

#
# this is an example for receive and transmit
#file= examples/lirc/lirc.conf

#
# this is an example of maxim/dallas semiconductors
# the new type can be taken for the most interfaces
# if you have some of this semiconductors set this documented file
#-------------------------------------------------------------------
#file= examples/maxim/thermostat.conf

#
# this is an example of the K8055 port from Vellemann
# the new type have the same properties of the most interfaces
# if you have this port set this documented file
#-------------------------------------------------------------------
#file= examples/vellemann/k8055.conf


##################################################################################################################
#
#      ppi-server config file of measure routines
#      writen by Alexander Kolli <ppi-server@magnificat.at>
#
#
#  this config file measure.conf have one or more folder which running
#  in extra threads. All folder have one or more subroutines called with attribute name
#  example:
#        folder= <foldername>
#        name= <subroutinename>
#        type= <type as follow>
#        [some properties for subroutine]
#        name= <new subroutine>
#        ...
#        folder= <new foldername>
#        name= <new subroutine>
#        ...
#
#  on any place (better before any defined folder, or at end of config file) 
#  can also be defined any external file (with parameter file and value as filename with path)
#  where be the same structure folder and subroutines (see for example the definition bellow).
#  Follow standard types can be set
#  and they need also the properties which in <> brackets or optional properties in [] brackets
#  by the attribute action all values are optional
#  read the description under PROPERTIES and ACTIONS
#
#
#   TYPES:         properties and actions:
#  --------       -------------------------
#
#   DEBUG          properties: [begin&|while&|end], [string], [value], [perm]
#             [ this subroutine is only for debugging in the same command line shell where the ppi-server is running.
#               the string from parameter [string] and value from parameter [value] will be written to command line
#               when the case of begin, while, end is given or the subroutine was set from outside
#               maybe with ppi-client to DEBUG (./ppi-client DEBUG <folder>:<subroutine>)
#               The own value of the DEBUG subroutine is true by writing output elsewhere false
#               so you can define more DEBUG subroutines which link to one DEBUG subroutine with property while
#               and you have than set only one DEBUG subroutine to write output.
#               More string parameters and value parameters can be set to define the debug string
#               The output is writing on interaction from [string] and [value]. Begins always with string if set.
#               If the [value] should be the first, define first an null string (string= "")
#               By debugging this subroutine the debug level do not show starting and ending folder in debug mode      ]
#
#   SET            properties: <begin&|while&|end>, <from>, <set>, [perm], [default]
#                  actions: db
#             [ with this subroutine your can set an value from one ore more parameter 'from' to
#               one ore more parameter 'set' in the case of begin, while and end.
#               If you have more 'set' parameter you can have one 'from' parameter, in this case you set all subroutines
#               with the same 'from' parameter value, or the same count of 'from' parameter than 'set'.
#               The own value of the SET subroutine will be true when the case of begin, while, end is given
#               elsewhere false                                                                                               ]
#
#   SHELL          properties: <begin&|while&|end>, <begincommand&|whilecommand&|endcommand>, [runuser]
#                  actions: db, wait, block
#             [ starts an shell command in the case of <begom|while|end> is correct.
#               Value of subroutine by an ERROR is -1 or 127. See log File for Errors or debug subroutine.
#               If action wait not be set value can be 0 when no command produced,
#               1 for begin-, 2 for while- and 3 for endcommand.
#               The errors only be seen when you debug the subroutine with ppi-client DEBUG <folder>:<subroutine>.
#               If action wait is set, the value of the subroutine is the return value of the produced command.      ]
#
#   SWITCH         properties: <begin&|while&|end> [lwhile], [link], [perm], [default], [perm]
#                  actions:    db
#             [ the type SWITCH is an holder for 0 or 1
#               beginning or ending in the case of defined subroutines
#               and can also set from outside, when permission given     ]
#
#   TIMER          properties: [mtime|(day&|hour&|min&|sec&|millisec&|microsec)], [direction], ]<begin&|while&|end>, [setnull],  [lwhile], [link], [perm]
#                  actions: db, measure, sec, micro
#             [ this type have three functionalities:
#               1 - measure the time between the subroutine active inside begin/while/end
#                   if no property of mtime or day, hour, min and so on be set.
#               2 - count the time in the case of begin and or while down to 0
#                   beginning by the time set with day, hour, min, sec, millisec, microsec or allone with mtime from other subroutine
#                   previously when a situation arises that while ending or property end is achieved, only when set,
#                   the count down to 0 is also reached.
#                   The next pass of this subroutine when 0 was reached before, the value is -1
#                   this is also the case if no count down running.
#                   When the count down finished with 0, but inside while/end the routine found no ending
#                   the subroutine begins again to run with full time.
#               3 - count also the time like point 2, but when stopping the subroutine hold the actual value
#                   this case is given when the property direction be set with 0 or 1
#               both variants measure or count down in seconds by default or action sec be set
#               when action micro be set, subroutine measure or count down in microseconds                                                      ]
#
#   VALUE          properties: [min & max], [default], [while], [value], [lwhile], [link], [perm]
#                  actions:    int, db
#             [ VALUE is an holder in the range of min and max
#               can set from outside when permission given,
#               or defined with parameter value (more than one)
#               which value parameter will be used when more set than one
#               can be defined in while parameter. Similary, the value of this
#               subroutine will be shared with other when the link parameter be set.
#               The definition to use which link is also defined in lwhile
#               If min and max not be set or with false values defined,
#               the range can have all values                                         ]
#
#
#   PROPERTIES:
#  -------------
#          the value of some properties can be a truth-value 'true' or 'false', comparison of numbers
#          or point to an other subroutine intern of folder <subroutine-name>
#          or show to an subroutine outside the folder <folder-name>:<subroutine-name>.
#          if this value is not null ('0') the case is given, same like 'true'. Elsewhere by null the case not given 'false'.
#          The subroutines can also comparing (=><) with an value or an other subroutine
#          and more comparisons can be separated with an & (and) or an | (or).
#          inside this property can also defined an if-sentence with <value> ? <then> : <else>
#          But heads up! when you have an colon ':' inside the then clause, define it under brackets '(<then>)'
#          for better overview in the properties description we call it as defined-value
#          elsewhere it be called as subroutine or number
#
#   begin          - do reading or writing if begin status occurring
#                    specific for type TIMER by no set action measure:
#                        subroutine beginning always with full time again
#                    for types SWITCH, SET and TIMER
#                    the value can be an defined-value
#
#   begincommand   - the value can be an shell command for the commandline
#                    this command will have effect when the case of <while> begin
#                    for type SHELL
#                    the value can be an string of shell commands
#
#   day            - after days the end will be reached
#                    for type TIMER
#                    the value can be an integer of hours
#
#   default        - when the server starting the first time
#                    or by every start if the action db not set
#                    elsewhere the default not be set and no db
#                    the value to begin is 0
#                    for types SWITCH, SET and VALUE
#                    the value can be 0 or 1 for SWITCH
#                    or the defined range for VALUE
#
#   direction      - advice the subroutine in which direction to count
#                    0 or lower - the subroutine count in direction to 0
#                    1 or higher - in direction to full setting time
#                    for the type TIMER
#                    the value can be an defined-value
#
#   end            - end read or write ending when state occurring
#                    specific for type TIMER by no set action measure:
#                        when state occuring before count down was finished
#                        the value of subroutine will be set directly to 0
#                    for the type SWITCH, SET and TIMER
#                    the value can be an defined-value
#
#   endcommand     - the value can be an shell command for the commandline
#                    this command will have effect when the case of <while> ending
#                    for type SHELL
#
#   file           - on any place (better before beginning an folder or on end of file)
#                    can also be defined any external files
#                    which have the same structure of folder and subroutines like this file
#                    the value can be an string of path definition with including file
#
#   from           - calculate the value from this string
#                    for type SET
#                    the value can be an defined-value
#
#   hour           - after houers the end will be reached
#                    for type TIMER
#                    the value can be an integer of hours
#
#   link           - share the own value with an other subroutine
#                    when be used more than one link,
#                    which used can be defined with the parameter lwhile.
#                    for type SWITCH, VALUE and TIMER
#                    the value can be one [folder:]subroutine
#
#   lwhile         - calculate which link parameter should be used
#                    if no lwhile parameter be set, but an link parameters
#                    subroutine will be an fix share to the linked [folder:]subroutine
#                    When result of lwhile is 0, no link be set
#                    1 for the first link, 2 for the second and so on
#                    by result of higher than link's exist, server writes an WANING into log-file
#                    for type SWITCH, VALUE and TIMER
#                    the value can be an defined-value
#
#   max            - maximal range for value
#                    if min or max not be set, the value have the hole range
#                    for type VALUE
#                    the value can be an floating value when action int not be set,
#                    elsewhere an integer
#
#   microsec       - after microseconds the end will be reached
#                    for type TIMER
#                    the value can be an integer of microseconds
#
#   millisec       - after milliseconds the end will be reached
#                    for type TIMER
#                    the value can be an integer of milliseconds
#
#   min            - minimal range for value
#                    if min or max not be set, the value have the hole range
#                    for type VALUE
#                    the value can be an floating value when action int not be set,
#                    elsewhere an integer
#
#   min            - after minutes the end will be reached
#                    for type TIMER
#                    the value can be an integer of minutes
#
#   mtime          - after this time be reached
#                    for type TIMER
#                    if this propertie set the other times with day&|hour&|min&|sec&|millisec&|microsec
#                    can not be set.
#                    the value can be an defined-value maybe to an other TIMER with action time
#
#   perm           - the given permission by access from outside to the server
#                    if no permission be set, nobody has access to the subroutine
#                    root has access to all read and write groups
#                    this property can be defined for all types
#                    the value can be a group defined in access.conf
#
#   runuser        - the value can be an string of existing user on system
#                    this command allow the subroutine to start the shell command
#                    inside specific user account
#                    for type SHELL
#                    the value can be an string of shell commands
#
#   sec            - after seconds the end will be reached
#                    for type TIMER
#                    the value can be an integer of seconds
#
#   set            - set an value to this subroutine
#                    for type SET
#                    the value can be an subroutine or folder:subroutine
#
#   setnull        - subroutine will be set to null
#                    for type TIMER with action measure
#                    the value can be an defined-value
#
#   string         - can be an string for output on command line
#                    for type DEBUG
#                    the value can be an string
#
#   value          - define the content of an VALUE subroutine.
#                    for type VALUE and DEBUG
#                    specific for type VALUE
#                        when be used more than one value, which used can be defined
#                        with the parameter while.
#                        When the result from while is 0, the value for writing to output
#                        is the defined first value. By 1 the second and so on.
#                        If the result is not defined in cout of values (out of range) the default value will be
#                        the first if to low or the last when to high
#                    the value can be an defined-value
#
#   while          - do reading or writing while state be set
#                    parameter beginning only when parameter begin not set
#                    but can ending before parameter end will be reached for ending
#                    specific for type VALUE:
#                        can also define which value parameter be used
#                        otherwise when no value parameter defined
#                        this result will be the value
#                    specific for type TIMER by no set action measure:
#                        when no begin parameter be set by running count down
#                        count down do not begin again with full time
#                        also by ending before count down finished
#                        count down running down to 0 and then -1
#                    for types SWITCH, SET, VALUE, TIMER and SHELL
#                    the value can be an defined-value
#
#   whilecommand   - the value can be an shell command for the command line
#                    this command have effect during the case of <while> be given
#                    for type SHELL
#                    the value can be an string of shell commands
#
#
#   ACTIONS:
#  ----------
#    one or more actions can be set by the property action
#    when more be set, it must be separated with an pipe ('|')
#
#   block     - for type SHELL
#               if subroutine is defined with the action wait and the shell command do not
#               ending directly, it will be block the hole subroutine and maybe also other folders
#               in this case define the subroutine with action block. And while during the shell
#               command runs, the subroutine starting no new command, otherwise he lock only for result
#               This action is only useful wehen also action wait is set, and gives an warning by start server
#
#   db        - writing actual state on database
#               witch values are will be write from subroutines with this action
#               and how long the values are holding in database
#               you can read in default.conf or some defined configuration files
#               for explicitly modules
#
#   int       - for type VALUE
#               when the value or subroutine can have only an integer
#               elsewhere an floating number
#
#   measure   - for type TIMER
#               calculate time length and not as default an count down
#
#   micro     - for type TIMER
#               result is before decimal point full seconds and then milliseconds
#               and microseconds in 1000'th steps
#               the highest value can only be 60 * 60 seconds (3600)
#
#   sec       - for type TIMER (default)
#               result is an integer of seconds
#
#   time      - for type TIMER
#               if this action be set, the timer measure the time
#               otherwise the subroutine makes an count down
#
#   wait      - for type SHELL
#               subroutine should waiting for end of command
#               in this case the value of the subroutine is the return value of the command
#
##################################################################################################################


#
# this is an default example to show all exist components
# in examples/components.conf there only an subroutine
# from type SWITCH and type VALUE. Usable components
# are inside of client/components.desktop.
# For useable subroutines take a look inside
# examples/subroutines.conf
#-------------------------------------------------------------------
file= examples/component.conf
file= examples/subroutines.conf

#
# this is an example for receive and transmit
#file= examples/lirc/lirc.conf

#
# this is an example of maxim/dallas semiconductors
# the new type can be taken for the most interfaces
# if you have some of this semiconductors set this documented file
#-------------------------------------------------------------------
#file= examples/maxim/thermostat.conf

#
# this is an example of the K8055 port from Vellemann
# the new type have the same properties of the most interfaces
# if you have this port set this documented file
#-------------------------------------------------------------------
#file= examples/vellemann/k8055.conf




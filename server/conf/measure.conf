##################################################################################################################
#
#      ppi-server config file of measure routines
#      writen by Alexander Kolli <ppi@magnificat.at>
#
#
#  this config file measure.conf have one or more folder which running
#  in extra threads. All folder have one or more subroutines called with attribute name
#  example:
#        folder= <foldername>
#        name= <subroutinename>
#        type= <type as follow>
#        [some properties for subroutine]
#        name= <new subroutine>
#        ...
#        folder= <new foldername>
#        name= <subroutine>
#        ...
#
#  on any place (better before any defined folder, or at end of config file) 
#  can also be defined any external file (with parameter file and value as filename with path)
#  where be the same structure folder and subroutines (see for example the definition bellow).
#  Follow standard types can be set
#  and they need also the properties which in <> brackets or optional properties in [] brackets
#  by the attribute action all values are optional
#  read the description under PROPERTIES and ACTIONS
#
#
#   TYPES:         properties and actions:
#  --------       -------------------------
#
#   DEBUG          properties: [begin&|while&|end], [log], [string], [value], [perm]
#                  actions: print
#             [ this subroutine is only for debugging in the same command line shell where the ppi-server is running,
#               or logging into log-file when property log be set
#               the string from parameter [string] and value from parameter [value] will be written to command line
#               when the case of begin, while, end is given or the subroutine was set from outside
#               maybe with ppi-client to DEBUG (./ppi-client DEBUG <folder>:<subroutine>)
#               The own value of the DEBUG subroutine is true by writing output elsewhere false
#               so you can define more DEBUG subroutines which link to one DEBUG subroutine with property while
#               and you have than set only one DEBUG subroutine to write output.
#               More string parameters and value parameters can be set to define the debug string
#               The output is writing on interaction from [string] and [value]. Begins always with string if set.
#               If the [value] should be the first, define first an null string (string= "")
#               By debugging only this subroutine the debug level do not show starting and ending folder in debug mode      ]
#
#   SET            properties: <begin&|while&|end>, <from>, <set>, [perm], [default]
#                  actions: db, noinfo
#             [ with this subroutine your can set an value from one ore more parameter 'from' to
#               one ore more parameter 'set' in the case of begin, while and end.
#               If you have more 'set' parameter you can have one 'from' parameter, in this case you set all subroutines
#               with the same 'from' parameter value, or the same count of 'from' parameter than 'set'.
#               The own value of the SET subroutine will be true when the case of begin, while, end is given
#               elsewhere false                                                                                               ]
#
#   SHELL          properties: <begin&|while&|end>, <begincommand&|whilecommand&|endcommand>, [runuser]
#                  actions: db, last, wait, block, noinfo, noerrorlog
#             [ starts an shell command in the case of <begin|while|end> is correct.
#               The value of the subroutine is the exit code of the starting shell script when action wait be defined,
#               by an ERROR value is -1 or 127. See log File for Errors, or debug subroutine.
#               If action wait not be set value can be 0 when no command produced,
#               1 for begin-, 2 for while- and 3 for endcommand.
#               The script output only be seen when you debug the subroutine with ppi-client DEBUG <folder>:<subroutine>
#               The started script can also write some commands per normally printing over stdout to the ppi-server:
#                       PPI-SET <folder>:<subroutine> <value>
#                                                -     to write directly into ppi-server subroutines
#                                                      you can use the way with an separate connection over ppi-client
#                                                      but also this one for an better performance
#                       PPI-DEF stop <signal>    -     normaly by stopping ppi-server, shell starting routine
#                                                      sending to started shell script and all child processes
#                                                      the signal SIGTERM for termination.
#                                                      with command "PPI-DEF stop" the server change sending signal
#                                                      follow signals are allowed:
#                                                                             SIGHUP
#                                                                             SIGINT
#                                                                             SIGQUIT
#                                                                             SIGTRAP
#                                                                             SIGABRT
#                                                                             SIGBUS
#                                                                             SIGKILL
#                                                                             SIGUSR1
#                                                                             SIGUSR2
#                                                                             SIGPIPE
#                                                                             SIGALRM
#                                                                             SIGTERM
#                                                                             SIGSTOP
#                       PPI-DEF cycle-begin      -     when action 'block' be set (see under action: block)
#                                                      to hold the output for debugging closer
#                                                      output beginning always new when this command passed
#                                                      otherwise the hole output can be grow to 1000 lines 
#                       PPI-DEF log <error-level> <string:|begin|end>
#                                                -     writing log message into log files
#                                                      error-level be are the same then in server.conf
#                                                               DEBUG
#                                                               INFO
#                                                               WARNING
#                                                               ERROR and
#                                                               ALERT    
#                                                      when after the error-level be defined the name 'string'
#                                                      the one character string line after the colon will be written
#                                                      into the log file
#                                                      when defined the word 'begin' after the log level
#                                                      the hole next output will be written
#                                                      until the shell command writing an new PPI-DEF log command with end
#                                                      but no error-level   
#                       PPI-DEF noerrorlog         -   do not write shell script error into log file                            ]
#
#   SWITCH         properties: <begin&|while&|end>, [finished], [lwhile], [link], [perm], [default], [perm]
#                  actions:    db, noinfo, exact
#             [ the type SWITCH is an holder for 0 or 1
#               beginning or ending in the case of defined subroutines
#               and can also set from outside, when permission given     ]
#
#   TIMER          properties: [mtime|(year&|month&|day&|hour&|min&|sec&|millisec&|microsec)], [direction], <begin&|while&|end>, [setnull],  [lwhile], [link], [perm]
#                  actions: db, measure, alwaysbegin, poll, activate, years, months, days, hours, minutes, seconds, sec, micro, noinfo
#             [ this type have five functionalities:
#               1 - polling the time inside settings action of years, months, days, hours, minutes or seconds
#                   in the case of begin/while/end when set, otherwise all the time
#               2 - count the time in the case of begin and or while down to 0
#                   to an setting date when in subroutine action activate be set
#                   the date can be defined with attribute parameters of subroutine year, month, day, hour, min and sec
#               3 - count the time in the case of begin and or while down to 0
#                   beginning by the time set with day, hour, min, sec, millisec, microsec or allone with mtime from other subroutine
#                   previously when a situation arises that while ending or property end is achieved, only when set,
#                   the count down to 0 is also reached.
#                   The next pass of this subroutine when 0 was reached before, the value is -1
#                   value -1 is also the case if no count down running.
#                   When the count down finished with 0, but inside while/end the routine found no ending
#                   and action poll be set, the subroutine begins again to run with full time.
#               4 - count also the time like point 3, but when stopping the subroutine hold the actual value
#                   and this case can count also in both direction is given when the property direction be set with 0 or 1
#               5 - measure the time between the subroutine active inside begin/while/end
#                   if no property of mtime or day, hour, min and so on be set.
#               variants 1, 2 and 4 measure or count down in seconds by default (same as action sec be set)
#               when action micro be set, subroutine measure or count down in microseconds
#               variant 3 make the count down only for seconds.   
#               All variants measure the time, for begin to end, when the subroutine running
#               only for variants of 3 or 4, begin/end time will taken from other subroutines changing,
#               defined inside the parameters begin/while/end                                                                       ]
#
#   VALUE          properties: [min & max], [default], [while], [value], [lwhile], [link], [perm]
#                  actions:    int, db, noinfo
#             [ VALUE is an holder in the range of min and max
#               can set from outside when permission given,
#               or defined with parameter value (more than one)
#               which value parameter will be used when more set than one
#               can be defined in while parameter. similarly, the value of this
#               subroutine will be shared with other when the link parameter be set.
#               The definition to use which link is also defined in lwhile
#               If min and max not be set or with false values defined,
#               the range can have all values                                         ]
#
#
#   PROPERTIES:
#  -------------
#          the value of some properties can be a truth-value 'true' or 'false', comparison of numbers
#          or point to an other subroutine intern of folder <subroutine-name>
#          or show to an subroutine outside the folder <folder-name>:<subroutine-name>.
#          if this value is not null ('0') the case is given, same like 'true'. Elsewhere by null the case not given 'false'.
#          The subroutines can also comparing (=><) with an value or an other subroutine
#          and more comparisons can be separated with an & (and) or an | (or).
#          inside this property can also defined an if-sentence with <value> ? <then> : <else>
#          But heads up! when you have an colon ':' inside the then clause, define it under brackets '(<then>)'.
#          This hole stuff, for better overview in the properties description we call it as defined-value
#          elsewhere it be called as subroutine or number
#
#   begin          - for types SWITCH, SET and TIMER
#                    do reading or writing if begin status occurring
#                    specific for type TIMER by no set action measure:
#                        subroutine beginning always with full time again
#                    the value can be an defined-value
#
#   begincommand   - for type SHELL
#                    the value can be an shell command for the commandline
#                    this command will have effect when the case of <while> begin
#                    the value can be an string of shell commands
#
#   day            - for type TIMER
#                    after days the end will be reached
#                    the value can be an integer of hours
#
#   default        - for types SWITCH, SET and VALUE
#                    when the server starting the first time
#                    or by every start if the action db not set
#                    elsewhere the default not be set and no db
#                    the value to begin is 0#                    
#                    the value can be 0 or 1 for SWITCH
#                    or the defined range for VALUE
#
#   direction      - for the type TIMER
#                    advice the subroutine in which direction to count
#                    0 or lower - the subroutine count in direction to 0
#                    1 or higher - in direction to full setting time
#                    the value can be an defined-value
#
#   end            - for the type SWITCH, SET and TIMER
#                    end read or write ending when state occurring
#                    specific for type TIMER by no set action measure:
#                        when state occuring before count down was finished
#                        the value of subroutine will be set directly to 0                    
#                    the value can be an defined-value
#
#   endcommand     - for type SHELL
#                    the value can be an shell command for the commandline
#                    this command will have effect when the case of <while> ending
#
#   file           - on any place (better before beginning an folder or on end of file)
#                    can also be defined any external files
#                    which have the same structure of folder and subroutines like this file
#                    the value can be an string of path definition with including file
#
#   finished       - for type TIMER when case is 3 (count time down to 0) and action exact be set
#                    include time from ending to be finished inside running length of timer 
#                    the value can be an defined-value 
#
#   from           - for type SET
#                    calculate the value from this string
#                    the value can be an defined-value
#
#   hour           - for type TIMER
#                    after houers the end will be reached
#                    the value can be an integer of hours
#
#   link           - for type SWITCH, VALUE and TIMER
#                    share the own value with an other subroutine
#                    when be used more than one link,
#                    which used can be defined with the parameter lwhile.
#                    the value can be one [folder:]subroutine
#
#   log            - for type DEBUG
#                    logging string/value into log-file
#                    when no log property be set or also action 'print' be set
#                    the string/values are be displayed on command line
#                    value can be an string of
#                                  DEBUG
#                                  INFO
#                                  WARNING
#                                  ERROR
#                                  ALERT    
#
#   lwhile         - for type SWITCH, VALUE and TIMER
#                    calculate which link parameter should be used
#                    if no lwhile parameter be set, but an link parameters
#                    subroutine will be an fix share to the linked [folder:]subroutine
#                    When result of lwhile is 0, no link be set
#                    1 for the first link, 2 for the second and so on
#                    by result of higher than link's exist, server writes an WANING into log-file#                    
#                    the value can be an defined-value
#
#   max            - for type VALUE
#                    maximal range for value
#                    if min or max not be set, the value have the hole range
#                    the value can be an floating value when action int not be set,
#                    elsewhere an integer
#
#   microsec       - for type TIMER
#                    after microseconds the end will be reached
#                    the value can be an integer of microseconds
#
#   millisec       - for type TIMER
#                    after milliseconds the end will be reached
#                    the value can be an integer of milliseconds
#
#   min            - for type VALUE
#                    minimal range for value
#                    if min or max not be set, the value have the hole range
#                    the value can be an floating value when action int not be set,
#                    elsewhere an integer
#
#   min            - for type TIMER
#                    after minutes the end will be reached
#                    the value can be an integer of minutes
#
#   mtime          - for type TIMER
#                    this time define running length of subroutine
#                    if this property set, the other times with day&|hour&|min&|sec&|millisec&|microsec
#                    can not be set.
#                    the value can be an defined-value maybe to an other TIMER with action time
#
#   perm           - for all types
#                    the given permission by access from outside to the server
#                    if no permission be set, nobody has access to the subroutine
#                    root has access to all read and write groups
#                    the value can be a group defined in access.conf
#
#   runuser        - for type SHELL
#                    the value can be an string of existing user on system
#                    this command allow the subroutine to start the shell command
#                    inside specific user account
#                    the value can be an string of shell commands
#
#   sec            - for type TIMER
#                    after seconds the end will be reached
#                    the value can be an integer of seconds
#
#   set            - for type SET
#                    set an value to this subroutine
#                    the value can be an subroutine or folder:subroutine
#
#   setnull        - for type TIMER
#                    subroutine will be set to null
#                    the value can be an defined-value
#
#   string         - for type DEBUG
#                    can be an string for output on command line
#                    the value can be an string
#
#   value          - for type VALUE and DEBUG
#                    define the content of an VALUE subroutine.
#                    specific for type VALUE
#                        when be used more than one value, which used can be defined
#                        with the parameter while.
#                        When the result from while is 0, the value for writing to output
#                        is the defined first value. By 1 the second and so on.
#                        If the result is not defined in count of values (out of range) the default value will be
#                        the first if to low or the last when to high
#                    the value can be an defined-value
#
#   while          - for types SWITCH, SET, VALUE, TIMER and SHELL
#                    do reading or writing while state be set
#                    parameter beginning only when parameter begin not set
#                    but can ending before parameter end will be reached for ending
#                    specific for type VALUE:
#                        can also define which value parameter be used
#                        otherwise when no value parameter defined
#                        this result will be the value
#                    specific for type TIMER by no set action measure:
#                        when no begin parameter be set by running count down
#                        count down do not begin again with full time
#                        also by ending before count down finished
#                        count down running down to 0 and then -1
#                    the value can be an defined-value
#
#   whilecommand   - for type SHELL
#                    the value can be an shell command for the command line
#                    this command have effect during the case of <while> be given
#                    the value can be an string of shell commands
#
#
#   ACTIONS:
#  ----------
#    one or more actions can be set by the property action
#    when more be set, it must be separated with an pipe ('|')
#
#   activate    - for type TIMER
#                 count down the second to an setting date
#
#   alwaysbegin - for type TIMER
#                 begin count down of full time by every begin
#                 this action is only allowed when TIMER type run in case 2
#
#   block       - for type SHELL
#                 if subroutine is defined with the action wait and the shell command do not
#                 ending directly, it will be block the hole subroutine and maybe also other folders
#                 in this case define the subroutine with action block. And while during the shell
#                 command runs, the subroutine starting no new command, otherwise he lock only for result
#                 This action is only useful when also action wait is set, and gives an warning by start server
#                 when this action be set, only the parameter whilecommand is allowed
#
#   db          - writing actual state on database
#                 witch values are will be write from subroutines with this action
#                 and how long the values are holding in database
#                 you can read in default.conf or some defined configuration files
#                 for explicitly modules
#
#   exact       - for type TIMER in case of 3 or 4
#                 exclude the time of start folder to start subroutine
#                 (as hole folder running time) from running length of subroutine
#                 and wait then inside subroutine to the exact time 
#
#   int         - for type VALUE
#                 when the value or subroutine can have only an integer
#                 elsewhere an floating number
#
#   last        - tor type SHELL when no wait action be active
#                 showing for result last triggered command
#
#   measure     - for type TIMER
#                 calculate time length and not as default an count down
#
#   micro       - for type TIMER
#                 result is before decimal point full seconds and then milliseconds
#                 and microseconds in 1000'th steps
#                 the highest value can only be 60 * 60 seconds (3600)
#
#   noerrorlog  - for type SHELL
#                 do not write shell script error into log file
#                 maybe you need the result of script inside the subroutine and need for this reason no error in log file.
#                 If it's possible to write the command (PPI-DEF noerrorlog) into the script
#                 it's an better job to do this shortly before exit with number.
#                 Because when script ending on other position with an real error
#                 you can not see the error in log file (Only by debugging folder:subroutine)
#
#   noinfo      - for all types
#                 when any values from subroutine defined in begin/while/end was changed
#                 running inside an other folder, or before own subroutine in same folder
#                 folder from this subroutine will be started when this action not be set
#                 this action can be neccesary when begin/while/end only should be checked
#                 when an subroutine before was changed. In this case the hole folder
#                 do not running all the time when not needed and so performance can be holded lower
#
#   poll        - for type TIMER
#                 beginning time measure again by 0 or full time
#                 when no ending found inside while or end parameters
#                 this action is only allowed when TIMER type run in case 2 or 4
#
#   print       - for type DEBUG
#                 display string/value on command line
#                 this action is default when no log property be set
#
#   sec         - for type TIMER (default)
#                 result is an integer of seconds
#
#   wait        - for type SHELL
#                 subroutine should waiting for end of command
#                 in this case the value of the subroutine is the return value of the command
#
##################################################################################################################


#
# this is an default example to show all exist components
# in examples/components.conf there only an subroutine
# from type SWITCH and type VALUE. Usable components
# are inside of client/components.desktop.
# For useable subroutines take a look inside
# examples/subroutines.conf
#-------------------------------------------------------------------
file= examples/components.conf
file= examples/subroutines.conf

#
# this is an example for receive and transmit
#file= examples/lirc/lirc.conf

#
# this is an example of maxim/dallas semiconductors
# the new type can be taken for the most interfaces
# if you have some of this semiconductors set this documented file
#-------------------------------------------------------------------
#file= examples/maxim/thermostat.conf

#
# this is an example of the K8055 port from Vellemann
# the new type have the same properties of the most interfaces
# if you have this port set this documented file
#-------------------------------------------------------------------
#file= examples/vellemann/k8055.conf



